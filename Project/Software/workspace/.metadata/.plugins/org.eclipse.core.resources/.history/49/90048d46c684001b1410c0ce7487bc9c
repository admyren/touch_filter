/*
 * gpio.c
 *
 *  Created on: 10 mars 2021
 *      Author: Myren
 */

#include "gpio.h"

uint32_t gpio_init(gpio_device_t gpio_dev, gpio_config_t gpio_conf)
{
   uint32_t ret = 0;
   uint32_t i;
   gpio_dev->MODER;
   gpio_dev->OTYPER;
   gpio_dev->OSPEEDR;
   gpio_dev->PUPDR;
   gpio_dev->LCKR;
   gpio_dev->AFR[0];
   gpio_dev->AFR[1];

   for (i=0; i<0xf; ++i)
   {
      if (gpio_conf->pins & (1 << i))
      {
         // Set MODER to reset state
         gpio_dev->MODER &= ~(0x3 << (i << 1));
         switch(gpio_conf->mode)
         {
         case gpio_input:
            gpio_dev->MODER |= (0x0 << (i << 1));
            break;
         case gpio_gpo:
            gpio_dev->MODER |= (0x1 << (i << 1));
            break;
         case gpio_af:
            gpio_dev->MODER |= (0x2 << (i << 1));
            break;
         case gpio_am:
            gpio_dev->MODER |= (0x3 << (i << 1));
            break;
         default:
            break;
         }

         // Set OTYPER to reset state
         gpio_dev->OTYPER &= ~(0x1 << i);
         switch(gpio_conf->output_type)
         {
         case gpio_opp:
            gpio_dev->OTYPER |= (0x0 << i);
            break;
         case gpio_ood:
            gpio_dev->OTYPER |= (0x1 << i);
            break;
         default:
            break;
         }

         // Set OSPEEDR to reset state
         gpio_dev->OSPEEDR &= ~(0x3 << (i << 1));
         switch(gpio_conf->output_speed)
         {
         case gpio_ls:
            gpio_dev->OSPEEDR |= (0x0 << (i << 1));
            break;
         case gpio_ms:
            gpio_dev->OSPEEDR |= (0x1 << (i << 1));
            break;
         case gpio_hs:
            gpio_dev->OSPEEDR |= (0x2 << (i << 1));
            break;
         case gpio_vhs:
            gpio_dev->OSPEEDR |= (0x3 << (i << 1));
            break;
         default:
            break;
         }

         // Set PUPDR to reset state
         gpio_dev->PUPDR &= ~(0x3 << (i << 1));
         switch(gpio_conf->pull_up_down)
         {
         case gpio_no_pull:
            gpio_dev->PUPDR |= (0x0 << (i << 1));
            break;
         case gpio_pull_up:
            gpio_dev->PUPDR |= (0x1 << (i << 1));
            break;
         case gpio_pull_down:
            gpio_dev->PUPDR |= (0x2 << (i << 1));
            break;
         default:
            break;
         }

         // Set LCKR to reset state
         gpio_dev->LCKR &= ~(0x1 << i);
         switch(gpio_conf->lock)
         {
         case gpio_lock_off:
            gpio_dev->LCKR |= (0x0 << i);
            break;
         case gpio_lock_on:
            gpio_dev->LCKR |= (0x1 << i);
            break;
         default:
            break;
         }



      }

      if (gpio_lock_on == gpio_conf->lock)
      {
         gpio_dev->LCKR |= (1 << 0x10);
      }
   }

   return(ret);
}

void gpio_pin_set(gpio_device_t gpio_dev, uint32_t pins)
{

}

void gpio_pin_reset(gpio_device_t gpio_dev, uint32_t pins)
{

}

void gpio_pin_toggle(gpio_device_t gpio_dev, uint32_t pins)
{

}

uint32_t gpio_pin_read(gpio_device_t gpio_dev, gpio_pin_e pin)
{

}
