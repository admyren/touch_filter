/*
 * stm32_i2c.c
 *
 *  Created on: 28 aug. 2021
 *      Author: Myren
 */

/*
 * i2c_drv.c
 *
 *  Created on: 11 jan. 2020
 *      Author: Myren
 */

#include "stm32f405xx.h"
#include "i2c_drv.h"

void i2c_init(void)
{
   // This initializes the I2C1 peripheral
   // and its corresponding GPIOs
   // I2C1 uses the AF4 alternate function
   // SCL - PB6
   // SDA - PB7

   uint32_t pclk1;
   const uint32_t scl_freq = 100000;

   // Enable GPIOB peripheral clock
   RCC->AHB1ENR |= (1 << 1);
   // Alternate function
    GPIOB->MODER |= (2 << 14) | (2 << 12);
    // AF4 alternate function
    GPIOB->AFR[0] |= (4 << 28) | (4 << 24);

   // Enable I2C1 peripheral clock
   RCC->APB1ENR |= (1 << 21);

   // Periperal clock freqiency in MHz, 50MHz >= FREQ >= 2MHz
   I2C1->CR2 |= (0x001f & 45);

   // Set fast mode (400khz)
   //I2C1->CCR |= (1 << 15);

   // Set fast mode duty
   // I2C1->CCR |= (1 << 14);
   // Get frequency of peripheral clock
   pclk1 = HAL_RCC_GetPCLK1Freq();
   // Clock control, for an SCL freq. of approx. 100 kHz
   I2C1->CCR |= 0x0fff & (2*pclk1/scl_freq);

   // Maximum rise time of SCL, programmed with
   // rise =(max_rise_t/T_PCLK1)+1. Where T_PCLK1 is the
   // period time of the peripheral clock and max_rise_t
   // is the maximum rise time of SCL specified by the I2C specification.

   I2C1->TRISE |= (0x003f & ((pclk1/1000) + 1));

   // Peripheral enable
   I2C1->CR1 |= (1 << 0);
}

void i2c_start(void)
{
   // Start generation
   I2C1->CR1 |= (1 << 8);
   //Check if a start condition has been generated
   while(!(I2C1->SR1 & (1 << 0)));
}

void i2c_stop(void)
{
   // Stop generation
   I2C1->CR1 |= (1 << 9);
}

uint8_t i2c_checkReady(void)
{
   uint8_t ret = 1;
   uint16_t count = 0;
   // Check so the bus is not busy
   while(I2C1->SR2 & (1 << 1))
   {
      count++;
      if(count > 1000)
      {
         ret = 0;
         break;
      }
   }

   return ret;
}

void i2c_sendAddress(uint8_t addr)
{
   I2C1->DR = addr;
   // Wait until data register is empty
   while(!(I2C1->SR1 & (1 << 7)));
   // Wait until the ADDR bit is set
   while(!(I2C1->SR1 & (1 << 1)));
   volatile uint32_t dummy = I2C1->SR2;
}

void i2c_sendData(uint8_t data)
{
   I2C1->DR = data;
   while(!(I2C1->SR1 & (1 << 7)));
}


