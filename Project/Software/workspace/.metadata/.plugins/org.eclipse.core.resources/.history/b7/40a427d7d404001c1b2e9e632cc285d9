/*
 * stm32_uart.c
 *
 *  Created on: 28 mars 2021
 *      Author: Myren
 */
#include "stm32_uart.h"
#include "rcc.h"

static void DMA_config(DMA_Stream_TypeDef* hdma, DMA_InitVals idma);

void UART_Init(USART_TypeDef* huart, uint32_t baud, uint8_t* pDst, uint8_t size)
{
   // DMA1 and DMA2 clock enable
#ifdef DMA_AND_INTERRUPT_ENABLE
   RCC->AHB1ENR |= (1 << 22) | (1 << 21);
   DMA_InitVals DMA_Init;
#endif
   uint32_t pclk1;
   uint32_t div;
   uint8_t carry;
   // DMA1 clock enable
   //RCC->AHB1ENR |= (1 << 21);
   // UART4 clock enable
   RCC->APB1ENR |= (1 << 19);
   // GPIOC clock enable
   RCC->AHB1ENR |= (1 << 2);
   // PC10 -> TX, PC11 -> RX
   GPIOC->MODER |= (1 << 23) | (1 << 21);
   GPIOC->OSPEEDR |= (1 << 23) | (1 << 22) | (1 << 21) | (1 << 20);
   GPIOC->AFR[1] |= (8 << 12) | (8 << 8);
   // Calculate division factor
   pclk1 = HAL_RCC_GetPCLK1Freq();
   //pclk1 = 42000000U;
   //pclk1 = RCC_get_APB1_freq();
   div = pclk1 << 1;
   div = div/baud;
   carry = (uint8_t)(div & 0x01);
   div >>= 1;
   div += carry;
   huart->BRR |= (0x0000ffff & div);

   // These two also work
   //huart->BRR |= (42000000L)/baud;
   //huart->BRR |= (pclk1)/baud;

#ifdef DMA_AND_INTERRUPT_ENABLE
   // Idle line interrupt enable
   huart->CR1 |= (1 << 4);
#endif

   // UART enable, transmitter & receiver enable
   huart->CR1 |= (1 << 13) | (1 << 3) | (1 << 2);

#ifdef DMA_AND_INTERRUPT_ENABLE
   // UART4 RX DMA is on channel 4, stream 2 on DMA1
   // UART DMA receiver
   huart->CR3 |= (1 << 6);

   DMA_Init.channel = 4;
   DMA_Init.direction = 0; // Peripheral to memory
   DMA_Init.bufferSize = size;
   DMA_Init.memAddr = (uint32_t)pDst;
   DMA_Init.periphAddr = (uint32_t)(&huart->DR);
   DMA_Init.memDataSize = SIZE_BYTE;
   DMA_Init.periphDataSize = SIZE_BYTE;
   DMA_Init.mode = 1;   // Circular mode
   DMA_Init.compIntEnable = 1;
   DMA_Init.halfIntEnable = 0;

   DMA_config(DMA1_Stream2, DMA_Init);

   NVIC_SetPriorityGrouping(2);
   NVIC_SetPriority (DMA1_Stream2_IRQn, 8);
   NVIC_EnableIRQ(DMA1_Stream2_IRQn);

   NVIC_SetPriorityGrouping(2);
   NVIC_SetPriority (UART4_IRQn, 7);
   NVIC_EnableIRQ(UART4_IRQn);
#endif
}

// Data should be a null terminated string if size == 0.
// if size > 0 then it will send size number of elements
void UART_Transmit(USART_TypeDef* huart, uint8_t* data, uint8_t size)
{
   if(size == 0)
   {
      for(uint8_t i=0; data[i] != '\0'; i++)
      {

         huart->DR = data[i];
         while(!(huart->SR & (1 << 6)));
      }
   }
   else
   {
      for(uint8_t i=0; i<size; i++)
      {

         huart->DR = data[i];
         while(!(huart->SR & (1 << 6)));
      }
   }
}

static void DMA_config(DMA_Stream_TypeDef* hdma, DMA_InitVals idma)
{
   // Channel 7
   hdma->CR |= (idma.channel << 25);
   // Priority very high
   hdma->CR |= (3 << 16);
   // Data size for transfers
   hdma->CR |= (idma.memDataSize << 13) | (idma.periphDataSize << 11);
   // Memory increment mode
   hdma->CR |= (1 << 10);
   // Circular mode
   hdma->CR |= (1 << 8);
   // Number of transfers
   hdma->NDTR = idma.bufferSize;
   // Address to peripheral data registers
   hdma->PAR = idma.periphAddr;
   // Memory address
   hdma->M0AR = idma.memAddr;
   // Direction
   hdma->CR |= (idma.direction << 6);
   // Transfer and half transfer complete interrupt enable
   hdma->CR |= (idma.compIntEnable << 4) | (idma.halfIntEnable << 3);
   // Circular mode
   hdma->CR |= (idma.mode << 8);
   // Enable DMA
   hdma->CR |= (1 << 0);
}

#if 0

uint32_t UART_config(uart_reg_t* uart_dev, uart_config_t* uart_conf)
{
   uint32_t ret = 0;
   uint32_t hclk;
   uint32_t uart_div;

   /* Set OVER8 bit to over sample by 8 */
   uart_dev->CR1 |= 1 << 15;

   /* UART 2, 3, 4 and 5 is part of APB1 and uses
    * UART 1 and 6 is part of APB2 */

   hclk = RCC_get_APB1_freq();
   uart_div = (2000000 * hclk) / uart_conf->baud_rate;
   uart_dev->BRR = uart_div;

   if (DATA_BITS_8 == uart_conf->data_bits)
   {
      uart_dev->CR1 &= ~(1 << 12);
   }
   else
   {
      uart_dev->CR1 |= 1 << 12;
   }

   uart_dev->CR2 &= ~(0x3 << 12);
   if (STOP_BITS_2 == uart_conf->stop_bits)
   {
      uart_dev->CR2 |= 1 << 13;
   }

   if (enable == uart_conf->RX_enable)
   {
      uart_dev->CR1 |= 1 << 2;
   }

   if (enable == uart_conf->TX_enable)
   {
      uart_dev->CR1 |= 1 << 3;
   }



   /* Enable UART */
   uart_dev->CR1 |= 1 << 13;

   return(ret);
}

void UART_tx(uart_reg_t* uart_dev, uint8_t* data, uint32_t size)
{
   uint32_t i;
   for (i=0; i<size; i++)
   {
      uart_dev->DR = data[i];
      while(!(uart_dev->SR & (1 << 6)));
   }

}
#endif



