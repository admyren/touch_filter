/*
 * rcc.c
 *
 *  Created on: 17 mars 2021
 *      Author: Myren
 */

#include "rcc.h"
#include "gpio.h"
#include "stm32_flash.h"

uint32_t RCC_PLL_config(rcc_device_t* rcc_dev, clock_conf_t* clock_conf)
{
   uint32_t ret = 0;
   uint32_t PLLP_temp;
   uint32_t sysclk_freq;
   uint32_t div;

   if (HSE_CLK == clock_conf->source)
   {
      /* Turn on HSE clock and wait for it to stabilize  */
      rcc_dev->CR |= (1 << 16); /* HSEON bit */
      while (!(rcc_dev->CR & (1 << 17))); /* Wait for HSERDY bit to go high */
   }

   if (enable == clock_conf->PLL_enable)
   {
      /* Configure PLL */
      /* Set PLLM */
      rcc_dev->PLLCFGR &= ~(0x3F);
      rcc_dev->PLLCFGR |= (clock_conf->PLLM & 0x3F);
      /* Set PLLN */
      rcc_dev->PLLCFGR &= ~(0x1FF << 6);
      rcc_dev->PLLCFGR |= (clock_conf->PLLN & 0x1FF) << 6;
      /* Set PLLP */
      PLLP_temp = (clock_conf->PLLP - 2) >> 1;
      rcc_dev->PLLCFGR &= ~(0x3 << 16);
      rcc_dev->PLLCFGR |= (PLLP_temp & 0x3) << 16;
      /* Set PLLQ */
      rcc_dev->PLLCFGR &= ~(0xF << 24);
      rcc_dev->PLLCFGR |= (clock_conf->PLLQ & 0xF) << 24;

      if (HSE_CLK == clock_conf->source)
      {
         rcc_dev->PLLCFGR |= 1 << 22; /* Set PLLSRC bit */
      }
      else
      {
         rcc_dev->PLLCFGR &= ~(1 << 22); /* Clear PLLSRC bit */
      }

      rcc_dev->CR |= 1 << 24; /* Turn on PLL by setting PLLON bit */

      while (!(rcc_dev->CR & (1 << 25))); /* Wait for PLLRDY bit to go high */
      gpio_pin_set(GPIOC, gpio_pin_3);

      /* Calculate sys clk freq to determine flash wait states */
      sysclk_freq = ((HSE_CLK_FREQ_MHZ / clock_conf->PLLM) * clock_conf->PLLN) /
            clock_conf->PLLP;
      /* Select wait states for flash memory */
      FLASH->ACR &= ~0x7;
      if (sysclk_freq <= 30)
      {
         FLASH->ACR |= 0x0; /* Zero wait states */
      }
      else if (sysclk_freq <= 60)
      {
         FLASH->ACR |= 0x1; /* One wait state */
      }
      else if (sysclk_freq <= 90)
      {
         FLASH->ACR |= 0x2; /* Two wait states */
      }
      else if (sysclk_freq <= 120)
      {
         FLASH->ACR |= 0x3; /* Three wait states */
      }
      else if (sysclk_freq <= 150)
      {
         FLASH->ACR |= 0x4; /* Four wait states */
      }
      else if (sysclk_freq <= 180)
      {
         FLASH->ACR |= 0x5; /* Five wait states */
      }
      else if (sysclk_freq <= 210)
      {
         FLASH->ACR |= 0x6; /* Six wait states */
      }
      else if (sysclk_freq <= 240)
      {
         FLASH->ACR |= 0x7; /* Seven wait states */
      }

      /* Select PLL as system clock source */
      rcc_dev->CFGR &= ~0x3;
      rcc_dev->CFGR |= 0x2;
   }
   else
   {
      /* Select clock source */
      switch(clock_conf->source)
      {
      case HSE_CLK:
         rcc_dev->CFGR &= ~0x2;
         rcc_dev->CFGR |= 0x1;
         break;
      case HSI_CLK:
         rcc_dev->CFGR &= ~0x3;
         break;
      default:
         break;
      }
   }

   /* AHB prescaler */
   rcc_dev->CFGR &= ~(0xF << 4);
   switch(clock_conf->AHB_prescaler)
   {
   case AHB_DIV_2:
      div = 0x8;
      break;
   case AHB_DIV_4:
      div = 0x9;
      break;
   case AHB_DIV_8:
      div = 0xA;
      break;
   case AHB_DIV_16:
      div = 0xB;
      break;
   case AHB_DIV_64:
      div = 0xC;
      break;
   case AHB_DIV_128:
      div = 0xD;
      break;
   case AHB_DIV_256:
      div = 0xE;
      break;
   case AHB_DIV_512:
      div = 0xF;
      break;
   default:
      break;
   }
   rcc_dev->CFGR |= (clock_conf->AHB_prescaler & 0xF) << 4;
   /* APB1 prescaler */
   rcc_dev->CFGR &= ~(0x7 << 10);
   rcc_dev->CFGR |= (clock_conf->APB1_prescaler & 0x7) << 10;
   /* APB2 prescaler */
   rcc_dev->CFGR &= ~(0x7 << 13);
   rcc_dev->CFGR |= (clock_conf->APB2_prescaler & 0x7) << 13;

   return(ret);
}
