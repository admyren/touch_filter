/*
 * rcc.c
 *
 *  Created on: 17 mars 2021
 *      Author: Myren
 */

#include "rcc.h"
#include "gpio.h"
#include "stm32_flash.h"

uint32_t RCC_PLL_config(rcc_device_t* rcc_dev, clock_conf_t* clock_conf)
{
   uint32_t ret = 0;
   uint32_t PLLP_temp;
   uint32_t sysclk_freq;


   if (HSE_CLK == clock_conf->source)
   {
      /* Turn on HSE clock and wait for it to stabilize  */
      rcc_dev->CR |= (1 << 16); /* HSEON bit */
      while (!(rcc_dev->CR & (1 << 17))); /* Wait for HSERDY bit to go high */
   }

   if (enable == clock_conf->PLL_enable)
   {
      /* Configure PLL */
      /* Set PLLM */
      if (clock_conf->PLLM <= 63 || clock_conf->PLLM >= 2)
      {
         rcc_dev->PLLCFGR &= ~(0x3F);
         rcc_dev->PLLCFGR |= (clock_conf->PLLM & 0x3F);
      }
      else
      {
         ret = 1;
      }
      /* Set PLLN */
      rcc_dev->PLLCFGR &= ~(0x1FF << 6);
      rcc_dev->PLLCFGR |= (clock_conf->PLLN & 0x1FF) << 6;
      /* Set PLLP */
      PLLP_temp = (clock_conf->PLLP - 2) >> 1;
      rcc_dev->PLLCFGR &= ~(0x3 << 16);
      rcc_dev->PLLCFGR |= (PLLP_temp & 0x3) << 16;
      /* Set PLLQ */
      rcc_dev->PLLCFGR &= ~(0xF << 24);
      rcc_dev->PLLCFGR |= (clock_conf->PLLQ & 0xF) << 24;

      if (HSE_CLK == clock_conf->source)
      {
         rcc_dev->PLLCFGR |= 1 << 22; /* Set PLLSRC bit */
      }
      else
      {
         rcc_dev->PLLCFGR &= ~(1 << 22); /* Clear PLLSRC bit */
      }

      rcc_dev->CR |= 1 << 24; /* Turn on PLL by setting PLLON bit */

      while (!(rcc_dev->CR & (1 << 25))); /* Wait for PLLRDY bit to go high */
      gpio_pin_set(GPIOC, gpio_pin_3);

      /* Calculate sys clk freq to determine flash wait states */
      sysclk_freq
      /* Select wait states for flash memory */
      FLASH->ACR &= ~0x7;
      FLASH->ACR |= 0x5; /* Five wait states */

      /* Select PLL as system clock source */
      rcc_dev->CFGR &= ~0x3;
      rcc_dev->CFGR |= 0x2;
      //rcc_dev->CFGR |= 1 << 1;

   }
   else
   {
      /* Select clock source */
      switch(clock_conf->source)
      {
      case HSE_CLK:
         rcc_dev->CFGR &= ~0x2;
         rcc_dev->CFGR |= 0x1;
         break;
      case HSI_CLK:
         rcc_dev->CFGR &= ~0x3;
         break;
      default:
         break;
      }

   }

#if 1
   /* AHB prescaler */
   rcc_dev->CFGR &= ~(0xF << 4);
   rcc_dev->CFGR |= (clock_conf->AHB_prescaler & 0xF) << 4;
   /* APB1 prescaler */
   rcc_dev->CFGR &= ~(0x7 << 10);
   rcc_dev->CFGR |= (clock_conf->APB1_prescaler & 0x7) << 10;
   /* APB2 prescaler */
   rcc_dev->CFGR &= ~(0x7 << 13);
   rcc_dev->CFGR |= (clock_conf->APB2_prescaler & 0x7) << 13;
#endif
   return(ret);
}
